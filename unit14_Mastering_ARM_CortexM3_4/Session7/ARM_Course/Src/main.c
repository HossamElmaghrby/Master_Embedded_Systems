/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "STM32F103x6.h"
#include "stm32f103x6_GPIO_Driver.h"
#include "stm32f103x6_EXTI_Driver.h"
#include "core_cm3.h"
unsigned int flag = 0  , TASKA_Flag , TASKB_Flag ;
extern uint64_t _estack ;


#define MSP_Size    512
#define TASKA_Size  100
#define TASKB_Size  100

#define OS_SET_PSP(add)         __asm("MOV r0 , %0  \n\t MSR PSP , r0" : : "r" (add))
#define OS_SWITCH_SP_PSP        __asm("MRS r0 ,CONTROL \n\t MOV r1 , #0x02 \n\t ORR r0,r0,r1 \n\t MSR CONTROL ,r0")
#define OS_SWITCH_SP_MSP        __asm("MRS r0 ,CONTROL \n\t MOV r1 , #0x05 \n\t AND r0,r0,r1 \n\t MSR CONTROL ,r0")
#define OS_GENERATE_EXCEPTION   __asm("SVC #0x3")

enum CPUAccessLevel
{
	privilege,
	unprivilege
};

#define OS_Switch_CPUAccessLevl(Level) \
		switch(Level) \
		{ \
		case privilege :\
		__asm("MRS r0 ,CONTROL  \n\t"\
				"LSR r0 ,r0 ,#0x1 \n\t" \
				"LSL r0 ,r0 ,#0x1 \n\t" \
				"MSR CONTROL , r0"); \
				break ; \
		case unprivilege: \
		__asm("MRS r0 , CONTROL \n\t" \
				"ORR r0 ,r0 ,#0x1 \n\t" \
				"MSR CONTROL , r0");  \
				break ;  \
		}

void HardFault_Handler()
{

}
void MemManage_Handler()
{

}
void BusFault_Handler()
{

}
void UsageFault_Handler()
{

}


//Main stake
uint64_t _S_MSP ;
uint64_t _E_MSP ;

//Task A
uint64_t _S_PSP_TA ;
uint64_t _E_PSP_TA ;

//Task B
uint64_t _S_PSP_TB ;
uint64_t _E_PSP_TB ;

uint8_t  TASKA(uint8_t a ,uint8_t b ,uint8_t c)
{
	return a+b+c ;
}


uint8_t  TASKB(uint8_t a ,uint8_t b ,uint8_t c , uint8_t d)
{
	return a+b+c+d ;
}
void mainOS()
{
	_S_MSP  =  (int32_t)(&_estack) ;
	_E_MSP  = _S_MSP - MSP_Size ;

	_S_PSP_TA = _E_MSP - 8 ;
	_E_PSP_TA = _S_PSP_TA - TASKA_Size ;

	_S_PSP_TB = _E_PSP_TA - 8 ;
	_E_PSP_TB  = _S_PSP_TB - TASKB_Size ;

	while(1)
	{
		__asm("NOP");

		if(TASKA_Flag == 1)
		{
			//Set PSP Register = _S_PSP_TA
			OS_SET_PSP(_S_PSP_TA);

			//SP -> PSP
			OS_SWITCH_SP_PSP ;

			//Switch from privileged -> unprivileged
			OS_Switch_CPUAccessLevl( unprivilege ) ;

			TASKA_Flag = TASKA(1,2,3);

			//Switch from unprivileged ->privileged
			OS_GENERATE_EXCEPTION ;

			//SP-> MSP
			OS_SWITCH_SP_MSP ;
		}
		else if(TASKB_Flag == 1)
		{
			//Set PSP Register = _S_PSP_TB
			OS_SET_PSP(_S_PSP_TB);

			//SP -> PSP
			OS_SWITCH_SP_PSP ;

			//Switch from privileged -> unprivileged
			OS_Switch_CPUAccessLevl( unprivilege ) ;

			TASKB_Flag = TASKB(1,2,3 ,4);

			//Switch from unprivileged ->privileged
			OS_GENERATE_EXCEPTION ;

			//SP-> MSP
			OS_SWITCH_SP_MSP ;
		}

	}
}



void EXTI9_CallBack()
{
	if(flag == 0)
	{
		TASKA_Flag  = 1 ;
		flag = 1 ;
	}
	else if(flag == 1 )
	{
		TASKB_Flag = 1 ;
		flag = 0 ;
	}
}

void OS_SVC_Services(int* StackFramePointer)
{
	//OS_SVC_Stack -> r0 ->stackFramePointer
	//OS_SVC_Stack r0 ,r1,r2,r3 ,r12,LR ,PC ,XPSR

	uint8_t SVC_number ;
	uint8_t Val1 ,Val2 ;

	SVC_number = *((uint8_t*)(((uint8_t*)StackFramePointer [6])-2));
	Val1 = StackFramePointer[0];
	Val2 = StackFramePointer[1];

	switch(SVC_number)
	{
	case 1:  //ADD

		StackFramePointer[0] = Val1 + Val2 ;
		break ;
	case 2:  //SUB
		StackFramePointer[0] = Val1 - Val2 ;
		break ;
	case 3 : //MULL
		StackFramePointer[0] = Val1 * Val2 ;
		break ;
	}
}
__attribute ((naked)) void SVC_Handler()
{
   __asm("TST LR ,#4 \n\t"
		   "ITE EQ \n\t"
		   "MRSEQ R0 ,MSP \n\t"
		   "MRSNE R0 ,PSP \n\t"
		   "B OS_SVC_Services");
}

int OS_SVC_Set(int a , int b ,int SVC_ID)
{
	int result ;

	switch(SVC_ID)
	{
	case 1:  //ADD

		__asm("SVC #0X01");
		break ;

	case 2:  //SUB
		__asm("SVC #0X02");
		break ;

	case 3 : //MULL
		__asm("SVC #0X03");
		break ;
	}

    __asm("MOV %0 , R0 " : "=r" (result));

	return result ;
}
int main(void)
{
/*	RCC_GPIOA_CLK_EN() ;
	RCC_GPIOB_CLK_EN() ;
	RCC_AFIO_CLK_EN() ;


	EXTI_PinConfig_t EXTI_RQ ;

	EXTI_RQ.EXTI_PIN =EXTI_Pin9 ;
	EXTI_RQ.GPIO_Port =GPIOB ;
	EXTI_RQ.trigger_case =EXTI_Trigger_Rising ;
	EXTI_RQ.P_IRQ_CallBack =EXTI9_CallBack ;
	EXTI_RQ.IRQ_Enable =EXTI_IRQ_Enable ;
	MCAL_EXTI_GPIO_Init(&EXTI_RQ) ;
	mainOS();*/

   flag = 1 ;
   flag =  OS_SVC_Set(3, 2, 1);
   flag =  OS_SVC_Set(3, 2, 2);
   flag =  OS_SVC_Set(3, 2, 3);

	while(1)
	{

		if(flag)
		{

		}
	}
}
